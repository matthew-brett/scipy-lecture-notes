---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.6
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Control Flow

Controls the order in which the code is executed.

## if/elif/else

```{python}
if 2**2 == 4:
    print("Obvious!")
```

**Blocks are delimited by indentation**

::: {note}
:class: dropdown

Type the following lines in your Python interpreter, and be careful
to **respect the indentation depth**. The Jupyter / IPython shell automatically
increases the indentation depth after a colon `:` sign; to decrease the
indentation depth, go four spaces to the left with the Backspace key. Press the
Enter key twice to leave the logical block.
:::

```{python}
a = 10
```

```{python}
if a == 1:
    print(1)
elif a == 2:
    print(2)
else:
    print("A lot")
```

Indentation is compulsory in scripts as well. As an exercise, re-type the
previous lines with the same indentation in a script `condition.py`, and
execute the script with `run condition.py` in IPython.


## for/range

Iterating with an index:

```{python}
for i in range(4):
    print(i)
```

But most often, it is more readable to iterate over values:

```{python}
for word in ('cool', 'powerful', 'readable'):
    print('Python is %s' % word)
```


## while/break/continue

Typical C-style while loop (Mandelbrot problem):

```{python}
z = 1 + 1j
while abs(z) < 100:
    z = z**2 + 1
z
```

**More advanced features**

`break` out of enclosing for/while loop:

```{python}
z = 1 + 1j
```

```{python}
while abs(z) < 100:
    if z.imag == 0:
        break
    z = z**2 + 1
```

`continue` the next iteration of a loop.:

```{python}
a = [1, 0, 2, 4]
for element in a:
    if element == 0:
        continue
    print(1. / element)
```

## Conditional Expressions


### `if <OBJECT>:`

Evaluates to `False` for:

* any number equal to zero (0, 0.0, 0+0j)
* an empty container (list, tuple, set, dictionary, â€¦)
* `False`, `None`

Evaluates to `True` for:

* everything else

Examples:

```{python}
a = 10
if a:
    print("Evaluated to `True`")
else:
    print('Evaluated to `False')
```

```{python}
a = []
if a:
    print("Evaluated to `True`")
else:
    print('Evaluated to `False')
```


### `a == b:`

Tests equality, with logics::

```{python}
1 == 1.
```

### `a is b`

Tests identity: both sides **are the same object**:

```{python}
a = 1
b = 1.
a == b
```

```{python}
a is b
```

```{python}
a = 'A string'
b = a
a is b
```

### `a in b`

For any collection ``b``: ``b`` contains ``a`` :

```{python}
b = [1, 2, 3]
2 in b
```

```{python}
5 in b
```

If ``b`` is a dictionary, this tests that ``a`` is a key of ``b``.

```{python}
b = {'first': 0, 'second': 1}
# Tests for key.
'first' in b
```

```{python}
# Does not test for value.
0 in b
```


## Advanced iteration

**Iterate over any sequence**:

You can iterate over any sequence (string, list, keys in a dictionary, lines in
a file, ...):

```{python}
vowels = 'aeiouy'
```

```{python}
for i in 'powerful':
    if i in vowels:
        print(i)
```

```{python}
message = "Hello how are you?"
message.split() # returns a list
```

```{python}
for word in message.split():
    print(word)
```

::: {note}
:class: dropdown

Few languages (in particular, languages for scientific computing) allow to
loop over anything but integers/indices. With Python it is possible to
loop exactly over the objects of interest without bothering with indices
you often don't care about. This feature can often be used to make
code more readable.
:::

:::{warning}
It is not safe to modify the sequence you are iterating over.
:::

### Keeping track of enumeration number

Common task is to iterate over a sequence while keeping track of the
item number.

We could use while loop with a counter as above. Or a for loop:

```{python}
words = ('cool', 'powerful', 'readable')
for i in range(0, len(words)):
    print((i, words[i]))
```

But, Python provides a built-in function - `enumerate` - for this:

```{python}
for index, item in enumerate(words):
    print((index, item))
```


### Looping over a dictionary

Use **items**:

```{python}
d = {'a': 1, 'b':1.2, 'c':1j}
```

```{python}
for key, val in d.items():
    print('Key: %s has value: %s' % (key, val))
```


## List Comprehensions

Instead of creating a list by means of a loop, one can make use
of a list comprehension with a rather self-explaining syntax.

```{python}
[i**2 for i in range(4)]
```

::: {exercise-start}
:label: pi-wallis-ex
:class: dropdown
:::

Compute the decimals of Pi using the Wallis formula:

$$
\pi = 2 \prod_{i=1}^{\infty} \frac{4i^2}{4i^2 - 1}
$$

::: {exercise-end}
:::

::: {solution-start} pi-wallis-ex
:class: dropdown
:::


```{python}
from functools import reduce

pi = 3.14159265358979312

my_pi = 1.0

for i in range(1, 100000):
    my_pi *= 4 * i**2 / (4 * i**2 - 1.0)

my_pi *= 2

print(pi)
print(my_pi)
print(abs(pi - my_pi))
```

```{python}
num = 1
den = 1
for i in range(1, 100000):
    tmp = 4 * i * i
    num *= tmp
    den *= tmp - 1

better_pi = 2 * (num / den)

print(pi)
print(better_pi)
print(abs(pi - better_pi))
print(abs(my_pi - better_pi))
```

Solution in a single line using more advanced constructs (reduce, lambda,
list comprehensions):

```{python}
print(
    2
    * reduce(
        lambda x, y: x * y,
        [float(4 * (i**2)) / ((4 * (i**2)) - 1) for i in range(1, 100000)],
    )
)
```

::: {solution-end}
:::
