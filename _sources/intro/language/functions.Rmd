---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Defining functions

## Function definition

```{python}
def test():
    print('in test function')
```

```{python}
test()
```

:::{Warning}
Function blocks must be indented as other control-flow blocks.
:::

## Return statement

Functions can *optionally* return values.

```{python}
def disk_area(radius):
    return 3.14 * radius * radius
```

```{python}
disk_area(1.5)
```

:::{Note}
By default, functions return `None`.
:::

:::{Note}
Note the syntax to define a function:

- the `def` keyword;
- is followed by the function's **name**, then
- the arguments of the function are given between parentheses followed
  by a colon.
- the function body;
- and `return object` for optionally returning values.
:::

## Parameters

Mandatory parameters (positional arguments)

```{python}
```

```{python}
def double_it(x):
    return x * 2
```

```{python}
double_it(3)
```

```{python tags=c("raises-exception")}
double_it()
```

Optional parameters (keyword or named arguments)

```{python}
def double_it(x=2):
    return x * 2
```

```{python}
double_it()
```

```{python}
double_it(3)
```

Keyword arguments allow you to specify *default values*.

:::{warning}
Default values are evaluated when the function is defined, not when
it is called. This can be problematic when using mutable types (e.g.
dictionary or list) and modifying them in the function body, since the
modifications will be persistent across invocations of the function.

Using an immutable type in a keyword argument:

```{python}
bigx = 10
def double_it(x=bigx):
    return x * 2
```

```{python}
bigx = 1e9  # Now really big
double_it()
```

Using an mutable type in a keyword argument (and modifying it inside the
function body):

```{python}
def add_to_dict(args={'a': 1, 'b': 2}):
    for i in args.keys():
        args[i] += 1
    print(args)
```

```{python}
add_to_dict
```

```{python}
add_to_dict()
```

```{python}
add_to_dict()
```

```{python}
add_to_dict()
```
:::

::: {note}
:class: dropdown

More involved example implementing python's slicing:

```{python}
def slicer(seq, start=None, stop=None, step=None):
    """Implement basic python slicing."""
    return seq[start:stop:step]
```

```{python}
rhyme = 'one fish, two fish, red fish, blue fish'.split()
rhyme
```

```{python}
slicer(rhyme)
```

```{python}
slicer(rhyme, step=2)
```

```{python}
slicer(rhyme, 1, step=2)
```

```{python}
slicer(rhyme, start=1, stop=4, step=2)
```

The order of the keyword arguments does not matter:

```{python}
slicer(rhyme, step=2, start=1, stop=4)
```

but it is good practice to use the same ordering as the function's
definition.
:::

*Keyword arguments* are a very convenient feature for defining functions
with a variable number of arguments, especially when default values are
to be used in most calls to the function.

## Passing by value

::: {note}
:class: dropdown

Can you modify the value of a variable inside a function? Most languages
(C, Java, ...) distinguish "passing by value" and "passing by reference".
In Python, such a distinction is somewhat artificial, and it is a bit
subtle whether your variables are going to be modified or not.
Fortunately, there exist clear rules.

Parameters to functions are references to objects, which are passed by
value. When you pass a variable to a function, python passes the
reference to the object to which the variable refers (the **value**).
Not the variable itself.
:::

If the **value** passed in a function is immutable, the function does not
modify the caller's variable. If the **value** is mutable, the function
may modify the caller's variable in-place:

```{python}
def try_to_modify(x, y, z):
    x = 23
    y.append(42)
    z = [99] # new reference
    print(x)
    print(y)
    print(z)
```

```{python}
a = 77    # immutable variable
b = [99]  # mutable variable
c = [28]
try_to_modify(a, b, c)
```

```{python}
print(a)
```

```{python}
print(b)
```

```{python}
print(c)
```

Functions have a local variable table called a *local namespace*.

The variable `x` only exists within the function `try_to_modify`.

## Global variables

Variables declared outside the function can be referenced within the
function:

```{python}
x = 5
def addx(y):
    return x + y
```

```{python}
addx(10)
```

But these "global" variables cannot be modified within the function,
unless declared **global** in the function.

This doesn't work:

```{python}
def setx(y):
    x = y
    print('x is %d' % x)
```

```{python}
setx(10)
```

```{python}
x
```

This works:

```{python}
def setx(y):
    global x
    x = y
    print('x is %d' % x)
```

```{python}
setx(10)
```

```{python}
x
```

## Variable number of parameters

Special forms of parameters:
: - `*args`: any number of positional arguments packed into a tuple
  - `**kwargs`: any number of keyword arguments packed into a dictionary

```{python}
def variable_args(*args, **kwargs):
    print('args is', args)
    print('kwargs is', kwargs)
```

```{python}
variable_args('one', 'two', x=1, y=2, z=3)
```

## Docstrings

Documentation about what the function does and its parameters. General
convention:

```{python}
def funcname(params):
    """Concise one-line sentence describing the function.

    Extended summary which can contain multiple paragraphs.
    """
    # function body
    pass
```

```{python}
# Also assessible in Jupyter / IPython with "funcname?"
help(funcname)
```

:::{Note}
**Docstring guidelines**

For the sake of standardization, the [Docstring
Conventions](https://peps.python.org/pep-0257) webpage
documents the semantics and conventions associated with Python
docstrings.

Also, the NumPy and SciPy modules have defined a precise standard
for documenting scientific functions, that you may want to follow for
your own functions, with a `Parameters` section, an `Examples`
section, etc. See
<https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard>
:::

## Functions are objects

Functions are first-class objects, which means they can be:
: - assigned to a variable
  - an item in a list (or any collection)
  - passed as an argument to another function.

```{python}
va = variable_args
va('three', x=1, y=2)
```

## Methods

Methods are functions attached to objects. You've seen these in our
examples on *lists*, *dictionaries*, *strings*, etc...

## Exercises

:::{admonition} Exercise: Fibonacci sequence
:class: green

Write a function that displays the `n` first terms of the Fibonacci
sequence, defined by:

$$
\left\{     \begin{array}{ll}         U_{0} = 0 \\         U_{1} = 1 \\         U_{n+2} = U_{n+1} + U_{n}     \end{array} \right.
$$
:::

<!---
:ref:`fibonacci`
-->
:::{admonition} Exercise: Quicksort
:class: green

Implement the quicksort algorithm, as defined by wikipedia
:::

.. parsed-literal::

    function quicksort(array)
        var list less, greater
        if length(array) < 2
            return array
        select and remove a pivot value pivot from array
        for each x in array
            if x < pivot + 1 then append x to less
            else append x to greater
        return concatenate(quicksort(less), pivot, quicksort(greater))
