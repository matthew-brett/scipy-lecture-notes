---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

---
orphan: true
---

```{python tags=c("hide-input")}
import matplotlib.pyplot as plt
```
{mod}`scipy.ndimage` provides manipulation of n-dimensional arrays as
images.

# Geometrical transformations on images

Changing orientation, resolution, ..

```{python}
import scipy as sp
```

```{python}
# Load an image
face = sp.datasets.face(gray=True)
```

```{python}
# Shift, rotate and zoom it
shifted_face = sp.ndimage.shift(face, (50, 50))
shifted_face2 = sp.ndimage.shift(face, (50, 50), mode='nearest')
rotated_face = sp.ndimage.rotate(face, 30)
cropped_face = face[50:-50, 50:-50]
zoomed_face = sp.ndimage.zoom(face, 2)
zoomed_face.shape
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_image_transform_001.png
:align: center
:scale: 70
:target: auto_examples/plot_image_transform.html
```

```{python}
plt.subplot(151)
```

```{python}
plt.imshow(shifted_face, cmap=plt.cm.gray)
```

```{python}
plt.axis('off')
# etc.
```

# Image filtering

Generate a noisy face:

```{python}
import scipy as sp
face = sp.datasets.face(gray=True)
face = face[:512, -512:]  # crop out square on right
import numpy as np
noisy_face = np.copy(face).astype(float)
rng = np.random.default_rng()
noisy_face += face.std() * 0.5 * rng.standard_normal(face.shape)
```

Apply a variety of filters on it:

```{python}
blurred_face = sp.ndimage.gaussian_filter(noisy_face, sigma=3)
median_face = sp.ndimage.median_filter(noisy_face, size=5)
wiener_face = sp.signal.wiener(noisy_face, (5, 5))
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_image_filters_001.png
:align: center
:scale: 70
:target: auto_examples/plot_image_filters.html
```

Other filters in {mod}`scipy.ndimage.filters` and {mod}`scipy.signal`
can be applied to images.

:::{admonition} Exercise
:class: green

> Compare histograms for the different filtered images.
:::

# Mathematical morphology

:::{tip}
[Mathematical morphology](https://en.wikipedia.org/wiki/Mathematical_morphology) stems from set
theory. It characterizes and transforms geometrical structures. Binary
(black and white) images, in particular, can be transformed using this
theory: the sets to be transformed are the sets of neighboring
non-zero-valued pixels. The theory was also extended to gray-valued
images.
:::

```{image} /intro/scipy/image_processing/morpho_mat.png
:align: center
```

Mathematical-morphology operations use a *structuring element*
in order to modify geometrical structures.

Let us first generate a structuring element:

```{python}
el = sp.ndimage.generate_binary_structure(2, 1)
el
```

```{python}
el.astype(int)
```

- **Erosion** {func}`scipy.ndimage.binary_erosion`

```{python}
a = np.zeros((7, 7), dtype=int)
a[1:6, 2:5] = 1
a
```

```{python}
sp.ndimage.binary_erosion(a).astype(a.dtype)
```

```{python}
# Erosion removes objects smaller than the structure
sp.ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
```

- **Dilation** {func}`scipy.ndimage.binary_dilation`

```{python}
a = np.zeros((5, 5))
a[2, 2] = 1
a
```

```{python}
sp.ndimage.binary_dilation(a).astype(a.dtype)
```

- **Opening** {func}`scipy.ndimage.binary_opening`

```{python}
a = np.zeros((5, 5), dtype=int)
a[1:4, 1:4] = 1
a[4, 4] = 1
a
```

```{python}
# Opening removes small objects
sp.ndimage.binary_opening(a, structure=np.ones((3, 3))).astype(int)
```

```{python}
# Opening can also smooth corners
sp.ndimage.binary_opening(a).astype(int)
```

- **Closing:** {func}`scipy.ndimage.binary_closing`

:::{admonition} Exercise
:class: green

> Check that opening amounts to eroding, then dilating.
:::

An opening operation removes small structures, while a closing operation
fills small holes. Such operations can therefore be used to "clean" an
image.

```{python}
a = np.zeros((50, 50))
a[10:-10, 10:-10] = 1
rng = np.random.default_rng()
a += 0.25 * rng.standard_normal(a.shape)
mask = a>=0.5
opened_mask = sp.ndimage.binary_opening(mask)
closed_mask = sp.ndimage.binary_closing(opened_mask)
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_mathematical_morpho_001.png
:align: center
:scale: 70
:target: auto_examples/plot_mathematical_morpho.html
```

:::{admonition} Exercise
:class: green

> Check that the area of the reconstructed square is smaller
> than the area of the initial square. (The opposite would occur if the
> closing step was performed *before* the opening).
:::

For *gray-valued* images, eroding (resp. dilating) amounts to replacing
a pixel by the minimal (resp. maximal) value among pixels covered by the
structuring element centered on the pixel of interest.

```{python}
a = np.zeros((7, 7), dtype=int)
a[1:6, 1:6] = 3
a[4, 4] = 2; a[2, 3] = 1
a
```

```{python}
sp.ndimage.grey_erosion(a, size=(3, 3))
```

# Connected components and measurements on images

Let us first generate a nice synthetic binary image.

```{python}
x, y = np.indices((100, 100))
sig = np.sin(2*np.pi*x/50.) * np.sin(2*np.pi*y/50.) * (1+x*y/50.**2)**2
mask = sig > 1
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_connect_measurements_001.png
:align: center
:scale: 60
:target: auto_examples/plot_connect_measurements.html
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_connect_measurements_002.png
:align: right
:scale: 60
:target: auto_examples/plot_connect_measurements.html
```

{func}`scipy.ndimage.label` assigns a different label to each connected
component:

```{python}
labels, nb = sp.ndimage.label(mask)
nb
```

```{raw} html
<div style="clear: both"></div>
```

Now compute measurements on each connected component:

```{python}
areas = sp.ndimage.sum(mask, labels, range(1, labels.max()+1))
areas   # The number of pixels in each connected component
```

```{python}
maxima = sp.ndimage.maximum(sig, labels, range(1, labels.max()+1))
maxima  # The maximum signal in each connected component
```

```{image} /intro/scipy/auto_examples/images/sphx_glr_plot_connect_measurements_003.png
:align: right
:scale: 60
:target: auto_examples/plot_connect_measurements.html
```

Extract the 4th connected component, and crop the array around it:

```{python}
sp.ndimage.find_objects(labels)[3]
```

```{python}
sl = sp.ndimage.find_objects(labels)[3]
import matplotlib.pyplot as plt
plt.imshow(sig[sl])
```

See the summary exercise on {ref}`summary_exercise_image_processing` for a more
advanced example.
