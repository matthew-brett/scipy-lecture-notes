---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python} tags=c("hide-input")
import numpy as np
import matplotlib.pyplot as plt
```

# The NumPy array object

## What are NumPy and NumPy arrays?

### NumPy arrays


:**NumPy** provides:

    - extension package to Python for multi-dimensional arrays

    - closer to hardware (efficiency)

    - designed for scientific computation (convenience)

    - Also known as *array oriented computing*

|

.. sourcecode:: pycon

    >>> import numpy as np

```{python}
import numpy as np
a = np.array([0, 1, 2, 3])
a
```

:::{tip}
For example, An array containing:

- values of an experiment/simulation at discrete time steps

- signal recorded by a measurement device, e.g. sound wave

- pixels of an image, grey-level or colour

- 3-D data measured at different X-Y-Z positions, e.g. MRI scan

- ...
:::

**Why it is useful:** Memory-efficient container that provides fast numerical
operations.

```{python}
L = range(1000)
%timeit [i**2 for i in L]
```

```{python}
a = np.arange(1000)
%timeit a**2
```

<!---
extension package to Python to support multidimensional arrays
-->
<!---
diagram, import conventions
-->
<!---
scope of this tutorial: drill in features of array manipulation in
Python, and try to give some indication on how to get things done
in good style
-->
<!---
a fixed number of elements (cf. certain exceptions)
-->
<!---
each element of same size and type
-->
<!---
efficiency vs. Python lists
-->
### NumPy Reference documentation

- On the web: <https://numpy.org/doc/>

- Interactive help:

  ```{eval-rst}
  .. ipython::

     In [5]: np.array?
     String Form:<built-in function array>
     Docstring:
     array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0, ...
  ```

  :::{tip}
```{python}
help(np.array)
```
  :::

- Looking for something:

  ```{eval-rst}
  .. ipython::

     In [6]: np.con*?
     np.concatenate
     np.conj
     np.conjugate
     np.convolve
  ```

### Import conventions

The recommended convention to import NumPy is:

```{python}
import numpy as np
```

## Creating arrays

### Manual construction of arrays

- **1-D**:

```{python}
a = np.array([0, 1, 2, 3])
a
```

```{python}
a.ndim
```

```{python}
a.shape
```

```{python}
len(a)
```

- **2-D, 3-D, ...**:

```{python}
b = np.array([[0, 1, 2], [3, 4, 5]])    # 2 x 3 array
b
```

```{python}
b.ndim
```

```{python}
b.shape
```

```{python}
len(b)     # returns the size of the first dimension
```

```{python}
c = np.array([[[1], [2]], [[3], [4]]])
c
```

```{python}
c.shape
```

:::{admonition} Exercise: Simple arrays
:class: green

- Create a simple two dimensional array. First, redo the examples
  from above. And then create your own: how about odd numbers
  counting backwards on the first row, and even numbers on the second?
- Use the functions {func}`len`, {func}`numpy.shape` on these arrays.
  How do they relate to each other? And to the `ndim` attribute of
  the arrays?
:::

### Functions for creating arrays

:::{tip}
In practice, we rarely enter items one by one...
:::

- Evenly spaced:

```{python}
a = np.arange(10) # 0 .. n-1  (!)
a
```

```{python}
b = np.arange(1, 9, 2) # start, end (exclusive), step
b
```

- or by number of points:

```{python}
c = np.linspace(0, 1, 6)   # start, end, num-points
c
```

```{python}
d = np.linspace(0, 1, 5, endpoint=False)
d
```

- Common arrays:

```{python}
a = np.ones((3, 3))  # reminder: (3, 3) is a tuple
a
```

```{python}
b = np.zeros((2, 2))
b
```

```{python}
c = np.eye(3)
c
```

```{python}
d = np.diag(np.array([1, 2, 3, 4]))
d
```

- {mod}`np.random`: random numbers (Mersenne Twister PRNG):

```{python}
rng = np.random.default_rng(27446968)
a = rng.random(4)       # uniform in [0, 1]
a
```

```{python}
b = rng.standard_normal(4)      # Gaussian
b
```

:::{admonition} Exercise: Creating arrays using functions
:class: green

- Experiment with `arange`, `linspace`, `ones`, `zeros`, `eye` and
  `diag`.
- Create different kinds of arrays with random numbers.
- Try setting the seed before creating an array with random values.
- Look at the function `np.empty`. What does it do? When might this be
  useful?
:::

<!---
EXE: construct 1 2 3 4 5
-->
<!---
EXE: construct -5, -4, -3, -2, -1
-->
<!---
EXE: construct 2 4 6 8
-->
<!---
EXE: look what is in an empty() array
-->
<!---
EXE: construct 15 equispaced numbers in range [0, 10]
-->
## Basic data types

You may have noticed that, in some instances, array elements are displayed with
a trailing dot (e.g. `2.` vs `2`). This is due to a difference in the
data-type used:

```{python}
a = np.array([1, 2, 3])
a.dtype
```

```{python}
b = np.array([1., 2., 3.])
b.dtype
```

:::{tip}
Different data-types allow us to store data more compactly in memory,
but most of the time we simply work with floating point numbers.
Note that, in the example above, NumPy auto-detects the data-type
from the input.
:::

______________________________________________________________________

You can explicitly specify which data-type you want:

```{python}
c = np.array([1, 2, 3], dtype=float)
c.dtype
```

The **default** data type is floating point:

```{python}
a = np.ones((3, 3))
a.dtype
```

There are also other types:


:Bool:

  .. sourcecode:: pycon

        >>> e = np.array([True, False, False, True])
        >>> e.dtype
        dtype('bool')

:Strings:

  .. sourcecode:: pycon

        >>> f = np.array(['Bonjour', 'Hello', 'Hallo'])
        >>> f.dtype     # <--- strings containing max. 7 letters
        dtype('<U7')

:Much more:

    * ``int32``
    * ``int64``
    * ``uint32``
    * ``uint64``

.. XXX: mention: astype


Basic visualization
-------------------

<!---
XXX: mention: astype
-->
## Basic visualization

Now that we have our first data arrays, we are going to visualize them.

Start by launching IPython:

```bash
$ ipython # or ipython3 depending on your install
```

Or the notebook:

```bash
$ jupyter notebook
```

Once IPython has started, enable interactive plots:

```{python}
%matplotlib
```

Or, from the notebook, enable plots in the notebook:

```{python}
%matplotlib inline
```

The `inline` is important for the notebook, so that plots are displayed in
the notebook and not in a new window.

*Matplotlib* is a 2D plotting package. We can import its functions as below:

```{python}
import matplotlib.pyplot as plt  # the tidy way
```

And then use (note that you have to use `show` explicitly if you have not enabled interactive plots with `%matplotlib`):

```{python}
plt.plot(x, y)       # line plot
plt.show()           # <-- shows the plot (not needed with interactive plots)
```

Or, if you have enabled interactive plots with `%matplotlib`:

```{python}
plt.plot(x, y)       # line plot
```

- **1D plotting**:

```{python}
x = np.linspace(0, 3, 20)
y = np.linspace(0, 9, 20)
plt.plot(x, y)       # line plot
```

```{python}
plt.plot(x, y, 'o')  # dot plot
```

```{image} auto_examples/images/sphx_glr_plot_basic1dplot_001.png
:align: center
:target: auto_examples/plot_basic1dplot.html
:width: 40%
```

- **2D arrays** (such as images):

```{python}
rng = np.random.default_rng(27446968)
image = rng.random((30, 30))
plt.imshow(image, cmap=plt.cm.hot)
```

```{python}
plt.colorbar()
```

```{image} auto_examples/images/sphx_glr_plot_basic2dplot_001.png
:align: center
:target: auto_examples/plot_basic2dplot.html
:width: 50%
```

:::{admonition} See also

More in the: {ref}`matplotlib chapter <matplotlib>`
:::

:::{admonition} Exercise: Simple visualizations
:class: green

- Plot some simple arrays: a cosine as a function of time and a 2D
  matrix.
- Try using the `gray` colormap on the 2D matrix.
:::

## Indexing and slicing

The items of an array can be accessed and assigned to the same way as
other Python sequences (e.g. lists):

```{python}
a = np.arange(10)
a
```

```{python}
a[0], a[2], a[-1]
```

:::{warning}
Indices begin at 0, like other Python sequences (and C/C++).
In contrast, in Fortran or Matlab, indices begin at 1.
:::

The usual python idiom for reversing a sequence is supported:

```{python}
a[::-1]
```

For multidimensional arrays, indices are tuples of integers:

```{python}
a = np.diag(np.arange(3))
a
```

```{python}
a[1, 1]
```

```{python}
a[2, 1] = 10 # third line, second column
a
```

```{python}
a[1]
```

:::{note}
- In 2D, the first dimension corresponds to **rows**, the second
  to **columns**.
- for multidimensional `a`, `a[0]` is interpreted by
  taking all elements in the unspecified dimensions.
:::

**Slicing**: Arrays, like other Python sequences can also be sliced:

```{python}
a = np.arange(10)
a
```

```{python}
a[2:9:3] # [start:end:step]
```

Note that the last index is not included! :

```{python}
a[:4]
```

All three slice components are not required: by default, `start` is 0,
`end` is the last and `step` is 1:

```{python}
a[1:3]
```

```{python}
a[::2]
```

```{python}
a[3:]
```

A small illustrated summary of NumPy indexing and slicing...

:::{only} latex
```{image} ../../pyximages/numpy_indexing.pdf
:align: center
```
:::

:::{only} html
```{image} ../../pyximages/numpy_indexing.png
:align: center
:width: 70%
```
:::

You can also combine assignment and slicing:

```{python}
a = np.arange(10)
a[5:] = 10
a
```

```{python}
b = np.arange(5)
a[5:] = b[::-1]
a
```

:::{admonition} Exercise: Indexing and slicing
:class: green

- Try the different flavours of slicing, using `start`, `end` and
  `step`: starting from a linspace, try to obtain odd numbers
  counting backwards, and even numbers counting forwards.

- Reproduce the slices in the diagram above. You may
  use the following expression to create the array:

```{python}
np.arange(6) + np.arange(0, 51, 10)[:, np.newaxis]
```
:::

:::{admonition} Exercise: Array creation
:class: green

Create the following arrays (with correct data types):

```{python}
[[1, 1, 1, 1],
 [1, 1, 1, 1],
 [1, 1, 1, 2],
 [1, 6, 1, 1]]

[[0., 0., 0., 0., 0.],
 [2., 0., 0., 0., 0.],
 [0., 3., 0., 0., 0.],
 [0., 0., 4., 0., 0.],
 [0., 0., 0., 5., 0.],
 [0., 0., 0., 0., 6.]]
```

Par on course: 3 statements for each

*Hint*: Individual array elements can be accessed similarly to a list,
e.g. `a[1]` or `a[1, 2]`.

*Hint*: Examine the docstring for `diag`.
:::

:::{admonition} Exercise: Tiling for array creation
:class: green

Skim through the documentation for `np.tile`, and use this function
to construct the array:

```{python}
[[4, 3, 4, 3, 4, 3],
 [2, 1, 2, 1, 2, 1],
 [4, 3, 4, 3, 4, 3],
 [2, 1, 2, 1, 2, 1]]
```
:::

## Copies and views

A slicing operation creates a **view** on the original array, which is
just a way of accessing array data. Thus the original array is not
copied in memory. You can use `np.may_share_memory()` to check if two arrays
share the same memory block. Note however, that this uses heuristics and may
give you false positives.

**When modifying the view, the original array is modified as well**:

```{python}
a = np.arange(10)
a
```

```{python}
b = a[::2]
b
```

```{python}
np.may_share_memory(a, b)
```

```{python}
b[0] = 12
b
```

```{python}
a   # (!)
```

```{python}
a = np.arange(10)
c = a[::2].copy()  # force a copy
c[0] = 12
a
```

```{python}
np.may_share_memory(a, c)
```

This behavior can be surprising at first sight... but it allows to save both
memory and time.

<!---
EXE: [1, 2, 3, 4, 5] -> [1, 2, 3]
-->
<!---
EXE: [1, 2, 3, 4, 5] -> [4, 5]
-->
<!---
EXE: [1, 2, 3, 4, 5] -> [1, 3, 5]
-->
<!---
EXE: [1, 2, 3, 4, 5] -> [2, 4]
-->
<!---
EXE: create an array [1, 1, 1, 1, 0, 0, 0]
-->
<!---
EXE: create an array [0, 0, 0, 0, 1, 1, 1]
-->
<!---
EXE: create an array [0, 1, 0, 1, 0, 1, 0]
-->
<!---
EXE: create an array [1, 0, 1, 0, 1, 0, 1]
-->
<!---
EXE: create an array [1, 0, 2, 0, 3, 0, 4]
-->
<!---
CHA: archimedean sieve
-->
:::{admonition} Worked example: Prime number sieve
:class: green

```{image} images/prime-sieve.png
```

Compute prime numbers in 0--99, with a sieve

- Construct a shape (100,) boolean array `is_prime`,
  filled with True in the beginning:

```{python}
is_prime = np.ones((100,), dtype=bool)
```

- Cross out 0 and 1 which are not primes:

```{python}
is_prime[:2] = 0
```

- For each integer `j` starting from 2, cross out its higher multiples:

```{python}
N_max = int(np.sqrt(len(is_prime) - 1))
for j in range(2, N_max + 1):
    is_prime[2*j::j] = False
```

- Skim through `help(np.nonzero)`, and print the prime numbers

- Follow-up:

  - Move the above code into a script file named `prime_sieve.py`
  - Run it to check it works
  - Use the optimization suggested in [the sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes):

  > 1. Skip `j` which are already known to not be primes
  > 2. The first number to cross out is $j^2$
:::

## Fancy indexing

:::{tip}
NumPy arrays can be indexed with slices, but also with boolean or
integer arrays (**masks**). This method is called *fancy indexing*.
It creates **copies not views**.
:::

### Using boolean masks

```{python}
rng = np.random.default_rng(27446968)
a = rng.integers(0, 21, 15)
a
```

```{python}
(a % 3 == 0)
```

```{python}
mask = (a % 3 == 0)
extract_from_a = a[mask] # or,  a[a%3==0]
extract_from_a           # extract a sub-array with the mask
```

Indexing with a mask can be very useful to assign a new value to a sub-array:

```{python}
a[a % 3 == 0] = -1
a
```

### Indexing with an array of integers

```{python}
a = np.arange(0, 100, 10)
a
```

Indexing can be done with an array of integers, where the same index is repeated
several time:

```{python}
a[[2, 3, 2, 4, 2]]  # note: [2, 3, 2, 4, 2] is a Python list
```

New values can be assigned with this kind of indexing:

```{python}
a[[9, 7]] = -100
a
```

:::{tip}
When a new array is created by indexing with an array of integers, the
new array has the same shape as the array of integers:

```{python}
a = np.arange(10)
idx = np.array([[3, 4], [9, 7]])
idx.shape
```

```{python}
a[idx]
```
:::

______________________________________________________________________

The image below illustrates various fancy indexing applications

:::{only} latex
```{image} ../../pyximages/numpy_fancy_indexing.pdf
:align: center
```
:::

:::{only} html
```{image} ../../pyximages/numpy_fancy_indexing.png
:align: center
:width: 80%
```
:::

:::{admonition} Exercise: Fancy indexing
:class: green

- Again, reproduce the fancy indexing shown in the diagram above.
- Use fancy indexing on the left and array creation on the right to assign
  values into an array, for instance by setting parts of the array in
  the diagram above to zero.
:::

<!---
We can even use fancy indexing and :ref:`broadcasting <broadcasting>` at
-->
<!---
the same time:
-->
%

<!---
.. sourcecode:: pycon
-->
%

```{python} tags=c("hide-input")
a = np.arange(12).reshape(3,4)
```
```{python} tags=c("hide-input")
a
```
<!---
array([[ 0,  1,  2,  3],
-->
<!---
[ 4,  5,  6,  7],
-->
<!---
[ 8,  9, 10, 11]])
-->
```{python} tags=c("hide-input")
i = np.array([[0, 1], [1, 2]])
```
```{python} tags=c("hide-input")
a[i, 2] # same as a[i, 2*np.ones((2, 2), dtype=int)]
```
<!---
array([[ 2,  6],
-->