---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Standard Library

:::{note}
Reference document for this section:

- The Python Standard Library documentation:
  <https://docs.python.org/3/library/index.html>
- Python Essential Reference, David Beazley, Addison-Wesley Professional
:::

## `os` module: operating system functionality

*"A portable way of using operating system dependent functionality."*

### Directory and file manipulation

Current directory:

```{python}
import os
os.getcwd()
```

List a directory:

```{python}
os.listdir(os.curdir)
```

Make a directory:

```{python}
os.mkdir('junkdir')
'junkdir' in os.listdir(os.curdir)
```

Rename the directory:

```{python}
os.rename('junkdir', 'foodir')
'junkdir' in os.listdir(os.curdir)
```

```{python}
'foodir' in os.listdir(os.curdir)
```

```{python}
os.rmdir('foodir')
'foodir' in os.listdir(os.curdir)
```

Delete a file:

```{python}
fp = open('junk.txt', 'w')
fp.close()
'junk.txt' in os.listdir(os.curdir)
```

```{python}
os.remove('junk.txt')
'junk.txt' in os.listdir(os.curdir)
```

### `os.path`: path manipulations

`os.path` provides common operations on pathnames.

```{python}
fp = open('junk.txt', 'w')
fp.close()
a = os.path.abspath('junk.txt')
a
```

```{python}
os.path.split(a)
```

```{python}
os.path.dirname(a)
```

```{python}
os.path.basename(a)
```

```{python}
os.path.splitext(os.path.basename(a))
```

```{python}
os.path.exists('junk.txt')
```

```{python}
os.path.isfile('junk.txt')
```

```{python}
os.path.isdir('junk.txt')
```

```{python}
os.path.expanduser('~/local')
```

```{python}
os.path.join(os.path.expanduser('~'), 'local', 'bin')
```

### Running an external command

```{python}
return_code = os.system('ls')
```

:::{note}
Alternative to `os.system`

A noteworthy alternative to `os.system` is the [sh
module](https://amoffat.github.com/sh/). Which provides much more convenient
ways to obtain the output, error stream and exit code of the external command.

```python
import sh
com = sh.ls()

print(com)
basic_types.rst   exceptions.rst   oop.rst              standard_library.rst
control_flow.rst  first_steps.rst  python_language.rst
demo2.py          functions.rst    python-logo.png
demo.py           io.rst           reusing_code.rst

type(com)
Out[33]: str
```
:::

### Walking a directory

`os.path.walk` generates a list of filenames in a directory tree.

```{python}
for dirpath, dirnames, filenames in os.walk(os.curdir):
    for fp in filenames:
        print(os.path.abspath(fp))
```

### Environment variables:

```ipython
In [2]: os.environ.keys()
Out[2]: KeysView(environ({'SHELL': '/bin/bash', 'PWD': '/home/mb312', 'LOGNAME': 'mb312', 'HOME': '/home/mb312', 'TERM': 'xterm', 'USER': 'mb312', 'SHLVL': '1', 'PATH': '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin', 'MAIL': '/var/mail/mb312', '_': '/usr/bin/python3', 'LC_CTYPE': 'C.UTF-8'}))

In [3]: os.environ['SHELL']
Out[3]: '/bin/bash'
```


## `shutil`: high-level file operations

The `shutil` provides useful file operations:

- `shutil.rmtree`: Recursively delete a directory tree.
- `shutil.move`: Recursively move a file or directory to another location.
- `shutil.copy`: Copy files or directories.

## `glob`: Pattern matching on files

The `glob` module provides convenient file pattern matching.

Find all files ending in `.txt`:

```{python}
import glob
glob.glob('*.txt')
```

## `sys` module: system-specific information

System-specific information related to the Python interpreter.

**Which version of Python** are you running and where is it installed:

```{python}
import sys
sys.platform
```

```{python}
sys.version
```

```{python}
sys.prefix
```

`sys.argv` gives you a **list of command line arguments** passed to a Python
script.  It is useful when you call as script with e.g. `python my_script.py some arguments`.  Inside the `my_arguments.py` script, you can get the passed arguments (here ['some', 'arguments']) with `sys.argv`.

`sys.path` is a list of strings that specifies the search path for
modules. Initialized from `PYTHONPATH`:

```{python}
sys.path
```

## `pickle`: easy persistence

Useful to store arbitrary objects to a file. Not safe or fast!

```{python}
import pickle
l = [1, None, 'Stan']
with open('test.pkl', 'wb') as file:
    pickle.dump(l, file)
```

```{python}
with open('test.pkl', 'rb') as file:
    out = pickle.load(file)
```

```{python}
out
```

## Exercises

::: {exercise-start}
:label: data-file-ex
:class: dropdown
:::

Write a function that will load the column of numbers in `data.txt` and
calculate the min, max and sum values.  Use no modules except those in the
standard library; specifically, do not use Numpy.

{download}`data.txt`:

::: {literalinclude} data.txt

:::

::: {exercise-end}
:::

::: {solution-start} data-file-ex
:class: dropdown
:::

```{python}
def load_data(filename):
    fp = open(filename)
    data_string = fp.read()
    fp.close()

    data = []
    for x in data_string.split():
        # Data is read in as a string. We need to convert it to floats
        data.append(float(x))

    # Could instead use the following one line with list comprehensions!
    # data = [float(x) for x in data_string.split()]
    return data
```

```{python}
data = load_data("data.txt")
# Python provides these basic math functions.
print(f"min: {min(data):f}")
print(f"max: {max(data):f}")
print(f"sum: {sum(data):f}")
```

::: {solution-end}
:::

::: {exercise-start}
:label: dir-sort-ex
:class: dropdown
:::

Implement a *script* that takes a directory name as argument, and
returns the list of '.py' files, sorted by name length.

**Hint:** try to understand the docstring of list.sort

::: {exercise-end}
:::

::: {solution-start} dir-sort-ex
:class: dropdown
:::

::: {literalinclude} solutions/dir_sort.py

:::

::: {solution-end}
:::


::: {exercise-start}
:label: path-site-ex
:class: dropdown
:::

Write a program to search your `PYTHONPATH` for the module `site.py`.

::: {exercise-end}
:::

::: {solution-start} path-site-ex
:class: dropdown
:::

::: {literalinclude} solutions/path_site.py

:::

::: {solution-end}
:::
